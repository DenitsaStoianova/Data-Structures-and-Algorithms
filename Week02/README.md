# Седмица 2 - Линеен двусвързан списък - обръщане, изтриване на елементи

Чрез директно използване на възлите на двусвързан списък да се решат следните задачи:

**Задача 1:**

Дефинирайте функцията void deleteAverage(Node* &first), която трие даден елемент от списъка, ако той е равен на средноаритметичното на първите два елемента, намиращи се от дясната му страна.
Пример:
Входен списък:
first: 5 -> 3 -> 7 ->  3.5 -> 2 -> 5 -> 4.5 -> 3 -> 6 -> 8 -> 4
Резултат:
deleteAverage(first): 3 -> 7 -> 2 -> 5 -> 3 -> 8 -> 4

Задача 2:
Дефинирайте функцията void deleteSum(Node* &first), която намира абсолютната стойност на разликата на най-малкия и най-големия елемент в списъка и ако в него съществува възел с такава стойност, изтрива всички негови срещания. В противен случай извежда съобщение, че не е намерен такъв елемент.
Пример:
Входен списък:
first: 3 -> 5 -> 2 -> 1 -> 4 -> 6 -> 5 -> 5 -> 1
Резултат:
deleteSum(first): 3 -> 2 -> 1 -> 4 -> 6 -> 1

Задача 3:
Дефинирайте функцията void reverseFirstK(Node* &first, int k), която обръща първите K елемента на подадения списък.
Пример:
Входен списък:
first: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8
Резултат:
reverseFirstK(first, 4): 4 -> 3 -> 2 -> 1 -> 5 -> 6 -> 7 -> 8 

Задача 4:
Дефинирайте функцията Node* constructReversed(Node* &list1,  Node* &list2), която намира пресечната точка на подадените списъци, съставя нов списък от общите им елементи и го връща като резултат в обърнат ред.
Пример:
Входни списъци:
list1: 7 -> 3 -> 9 -> 6 -> 1 -> 8 -> 4 -> 5
list2: 6 -> 7 -> 2 -> 1 -> 8 -> 4 -> 5
Резултат:
constructReversed(list1, list2):  5 -> 4 -> 8 -> 1

Задача 5:
Дефинирайте функцията Node* mergeLists(Node* &evens,  Node* &odds), която получава два списъка, първият от които се състои само от четни числа, а вторият – от нечетни, проверява дали всеки от тях изпълнява условието и при наличие на успех слива последователно елементите на подадените списъци в нов списък, редувайки четни с нечетни числа. Ако някой от списъците съдържа число, което не отговаря на условието, то трябва да бъде изтрито от списъка преди да се извърши сливането. 
Пример:
Входни списъци:
list1: 8 -> 2 -> 6 -> 4
list2: 5 -> 9 -> 7 -> 3 -> 1
Резултат:
mergeLists(list1, list2):  8 -> 5 -> 2 -> 9 -> 6 -> 7 -> 4 -> 3 -> 1
