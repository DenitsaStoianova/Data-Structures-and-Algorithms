# Седмица 1 - Линеен едносвързан и двусвързан списък

***Едносвързан списък***

[Имплементация](https://github.com/DenitsaStoianova/Data-Structures-and-Algorithms/tree/main/Week01/SinglyLinkedList-Implementation)

[Решения на задачите](https://github.com/DenitsaStoianova/Data-Structures-and-Algorithms/tree/main/Week01/SinglyLinkedList-Tasks)

***Чрез директно използване на възлите на едносвързан списък да се решат следните задачи:***

**Задача 1:** 

Дефинирайте функцията void swapWithSecond(Node* &first, int element), която намира подадената стойност в списъка и я разменя със стойността на елемента, намиращ се на две позиции напред в списъка (ако е възможно). Ако списъкът не съдържа подадената стойност се извежда съобщение, че не е възможна размяна.

```
Пример:
Входен списък: 
first: 1 -> 2 -> 3 -> 4 -> 5
Резултат:
swapWithSecond(first,3): 1 -> 2 -> 5 -> 4 -> 3
```

**Задача 2:** 

Дефинирайте функцията void splitList(Node* &first), която разделя подадения свързан списък по средата и принтира новополучените списъци.

```
Пример:
Входен списък: 
first: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10
Резултат:
splitList(first): 
1 -> 2 -> 3 -> 4 -> 5
6 -> 7 -> 8 -> 9 -> 10
```

**Задача 3:** 

Дефинирайте функцията Node* constructList(Node* &first, int n), която намира N-тия елемент от началото и от края на подадения списък и връща нов списък, състоящ се от елементите, намиращи се между тях.

```
Пример:
Входен списък: 
first: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10
Резултат:
constructList(first,3): 4 -> 5 -> 6 -> 7
```

**Задача 4:** 

Дефинирайте функцията void rearrangeList(Node* &first), която разделя подадения свързан списък по средата и разменя местата на първата и втората му половина (за удобство приемаме, че списъка се състои от четен брой елементи).

```
Пример:
Входен списък: 
first: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10
Резултат:
rearrangeList(first): 6 -> 7 -> 8 -> 9 -> 10 -> 1 -> 2 -> 3 -> 4 -> 5
```

***Двусвързан списък***

[Имплементация](https://github.com/DenitsaStoianova/Data-Structures-and-Algorithms/tree/main/Week01/DoublyLinkedList-Implementation)

[Имплементация с указател към последния елемент](https://github.com/DenitsaStoianova/Data-Structures-and-Algorithms/tree/main/Week01/DoublyLinkedList-LastPointerImplementation)

[Решения на задачите](https://github.com/DenitsaStoianova/Data-Structures-and-Algorithms/tree/main/Week01/DoublyLinkedList-Tasks)

***Чрез директно използване на възлите на двусвързан списък да се решат следните задачи:***

**Задача 1:** 

Дефинирайте функцията void swapNodes(Node* &first, int element) , която намира подадената стойност в списъка и я разменя със стойността на елемента, намиращ се на две позиции назад в списъка (ако е възможно). Ако списъкът не съдържа подадената стойност се извежда съобщение, че не е възможна размяна.

```
Пример:
Входен списък: 
first: 1 <=> 2 <=> 3 <=> 4 <=> 5 
Резултат:
swapNodes(first, 3): 3 <=> 2 <=> 1 <=> 4 <=> 5
```

**Задача 2:**

Дефинирайте функцията void addAfter(Node* &first, int afterElement, int addElement), която добавя нов възел в списъка след посочен елемент.

```
Пример:
Входен списък: 
first: 1 <=> 2 <=> 3 <=> 4 <=> 5 
Резултат:
addAfter (first, 3, 10): 1 <=> 2 <=> 3 <=> 10 <=> 4 <=> 5
```

**Задача 3:**

Дефинирайте функцията void moveLast(Node* &first), която мести последния елемент на списъка на първа позиция.

```
Пример:
Входен списък: 
first: 1 <=> 2 <=> 3 <=> 4 <=> 5 
Резултат:
moveLast(first): 5 <=> 1 <=> 2 <=> 3 <=> 4 
```

**Задача 4:**

Дефинирайте функцията void addElement(Node* &first, int N, int element), която добавя подадения елемент на всяка N-та позиция в списъка.

```
Пример:
Входен списък: 
first: 1 <=> 2 <=> 3 <=> 4 <=> 5 <=> 6 <=> 7 
Резултат:
addElement(first, 3, 11): 1 <=> 2 <=> 11 <=> 3 <=> 4 <=> 11 <=> 5 <=> 6 <=> 11 <=> 7 
```

